

**OSI七层模型**

open system interconnect开放式系统互联 参考模型，共7层，每一层都向上一层提供服务：

**五层模型**



## :one: 数据链路层

**数据链路层使用的信道有：**

> 点对点信道：一对一的点对点通信方式；
> 广播信道：一对多的广播通信方式，必须采用专用的共享信道协议来协调各主机之间的数据传送；

**数据链路：**就是在链路的基础上增加了实现通信协议的硬件和软件，就构成了数据链路；常用方法就是添加**适配器**（网卡）来实现，所以一般适配器包括数据链路层和物理层的功能；

数据链路层有三个基本问题：*封装成帧、透明传输、差错控制*

> 封装成帧：在一段数据的前后添加首部和尾部（**帧界定符**），构成一个数据帧；
> 透明传输：用**字节填充法**解决透明传输问题，在数据中出现的SOH、EOT控制字符前插入一个ESC转义字符；
> 差错控制：常用 **循环冗余检测CRC技术**实现差错控制，在发送数据包后面再添加供差错检测用的n位冗余码，在接收端，检验到出错后，路由会直接将包丢弃；因此仅用循环冗余检验CRC只能做到无差错接受，如果要做到可靠传输就要加入确认和重传机制；所以说CRC是一种无比特差错，不是无传输差错的检测机制；（接收到的包一定是无差错的，但是不代表所有的包都接收到了，可能有的包在差错检验时被丢弃了）；

**点对点协议PPP（point to point protocol）**，目前广域网应用最广泛的协议之一，优点在于简单；

> **PPP协议功能（应该满足的要求）：**简单、封装成帧、透明性、多种网络层协议（在同一条物理链路上同时支持多种网络层协议，如IP和IPX等）、多种链路类型（串行链路、并行链路等）、差错检测、检测连接状态、最大传送单元、网络层地址协商、数据压缩协商。
> **PPP协议帧格式：**首部中包含一个2字节的协议字段，中间是信息字段，最后是尾部；
> **PPP协议组成部分：**高级数据链路控制协议（HDLC）、链路控制协议LCP、网络控制协议NCP、认证协议（口令验证协议PAP、挑战握手验证协议CHAP等）
>
> 高级数据链路控制协议HDLC：提供一个将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是信息部分，长度受最大传送单元MTU的限制，PPP支持异步链路和面向比特的同步链路；
> 链路控制协议LCP：建立并维护数据链路连接，
> 网络控制协议NCP：允许在点到点连接上使用多种网络层协议（ip、arp、igmp、icmp）；
> PPP通讯是两个端点之间的通讯，每一端必须首先发送LCP packets数据来设定和测试数据链路，当链路建立后，peer才可以被认证，认证完成后，再通过发送NCP pockets来选定网络层协议，这些后续的通讯就可以再网络层进行了；具体的流程是：链路静止状态->链路建立状态->认证阶段->网络层协议阶段->链路终止阶段

---

## :two: 网络层

网络层提供的两种服务：虚电路服务、数据报服务；

数据报服务：发送分组时不需要先建立连接，数据报独立发送，不进行编号，同时也不提供服务质量的承诺；将可靠通信的任务推给运输层来实现（TCP/UDP），这样也降低了路由器的复杂度，降低网络造价；

各种中间设备：转发器（物理层）、网桥或桥接器（数据链路层）、路由器（网络层）、网关（网络层以上）；

**网际协议IP是TCP/IP体系中两个最主要的协议之一，同时与IP协议配套使用的还有四个协议：地址解析协议ARP、逆地址解析协议RARP、网际控制报文协议ICMP、网际组管理协议IGMP；一般就把ARP、RARP统一称为ARP协议，所以网络层的四个协议就是IP、ARP、ICMP、IGMP；**

### :zap: IP协议

#### **IP地址**

层次化IP地址，将32位的IP地址分为了网络ID和主机ID，同时将IP地址分为了五类；

```c++
/*
A类地址：8位网络号、24位主机号；网络号第一位是0；
B类地址：16位网络号、16位主机号；网络号前两位10；
C类地址：24位网络号、8位主机号；网络号前三位110；
D类地址：前四位1110；
E类地址：前四位1111；

第一位地址范围：A类1-126、B类128-191、C类192-224
主机号字段：全为1->广播；
         全为0->网络地址；
子网掩码：利用按位与的操作指明IP地址中哪部分是网络地址，哪部分是主机地址；         
```
广播地址：用于在同一个链路中，相互连接的主机之间发送数据包；广播又分为本地广播与直接广播；

D类与E类地址没有主机号，其中D类主要用于多播，E类为预留地址；

> IP分类的优点与缺点：
>
> ​	优点：简单明了，数据包在选路的时候可以基于网络地址，更加简单；
>
> ​	缺点：同一网络下没有地址层次，缺少地址的灵活性；不能很好的与现实网络想匹配，C类 主机数太少，B类主机数太多；

**无分类地址CIDR**

不再使用ABC这种分类的方式，而是直接将32位的IP地址划分为两部分，前面是网络号，后面是主机号；

表现形式为：IP/x，利用x表示网络号的位数，范围是0~32；

#### 子网划分

IPV4如果只使用有类来划分，会造成大量浪费或不够用，利用子网划分解决该问题，同时提高网络划分的灵活性；

VLSM可变长子网掩码：借用主机位最左边某几位作为子网位，划分出多个子网；

> 旧网络ID + 子网ID = 新网络ID
> 等长子网划分：等长子网划分就是将一个有类网络等分成多个子网络，所有子网的子网掩码都相同；
> 变长子网划分：变长子网划分就是在等长子网划分的基础上，分别取不同等分子网中的某个或多个子网；

#### **IP数据报**

IP数据报有两部分组成：**首部**、**数据部分**

![image-20200804213244035](D:\Song'Document\Mygit\ip_header)

> 版本号：表示该IP数据报使用的IP协议版本。（IPV4->4 / IPV6->6)
>
> 首部长度：整个报头的长度（包括可选字段），该长度以32位二进制数（4字节）为计数单位，接收端通过此域可以计算出报头在何处结束及从何处开始读数据。普通IP数据报（没有任何选项）该字段的值是5。
>
> 区分服务TOS：用于规定本数据报的处理方式  ->  0~2优先权（级别为0-7）、3-D-短延迟位、4-T-高吞吐位、5-R-高可靠位、6-7保留；
>
> 总长度：指整个IP数据报的长度（报头+数据），以字节为单位。利用头部长度字段和总长度字段就可以计算出IP数据报中数据内容的起始位置和长度。由于该字段长度为16位二进制数，因此理论上IP数据报最长可达65536个字节（事实上受物理网络的限制，要比这个数值小很多）。
>
> 标识：
>
> 标志：
>
> 片偏移：其值为当前数据报分片的开头字节数除以8；
>
> 生存时间TTL：指定数据报可以在网络中传输的最长时间。实际应用中把生存时间字段设置成了数据报可以经过的最大路由器数。TTL的初始值由源主机设置（通常为32、64、128或256），一旦经过一个处理它的路由器，它的值就减1。当该字段为0时，数据报就丢弃，并发送ICMP报文通知源主机，因此可以防止进入一个循环回路时，数据报无休止地传输下去。
>
> 协议：ICMP(1)、IGMP(2)、TCP(6)、UDP(17)、IPv6(41)、OSPF(89)
>
> 首部检验和：
>
> 源地址：
>
> 目的地址：
>
> 

**注意：**上图表示的数据，最高位在左边，记为0位；最低位在右边，记为31位。在网络中传输数据时，先传输0~7位，其次是8~15位，然后传输16~23位，最后传输24~31位。由于TCP/IP协议头部中所有的二进制数在网络中传输时都要求以这种顺序进行，因此把它称为`网络字节顺序`。在实际编程中，以其他形式存储的二进制数必须在传输数据前使用网络编程API函数把头部转换成网络字节顺序。----->联系到Linux高性能服务器编程书中的API函数

#### **IP转发分组的流程**

静态路由：需要管理员告诉路由器所有没有直连的网络下一跳给谁，适合小规模网络，不能自动调整路由；

动态路由：自动调整路由

> RIP协议：周期性广播路由表，选择路径的依据是最少的跳数，一般不适合大网络；
> OSPF协议：根据带宽选择协议；内部网关协议，向本自治系统中所有路由器发送信息，发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息；
> BGP协议：不同自治系统的路由器之间交换路由信息的协议；BGP只能是寻找一条能够到达目的网络，且比较好的路由，而并非寻找到一条最佳路由；





#### **IP地址与MAC地址：**

链路层使用`MAC地址`；网络层使用`IP地址`。

>计算机A与计算机B通信过程：交换机基于数据帧的MAC地址转发数据帧，路由器基于数据包的IP地址转发数据包；数据包在传输的过程中不变，经过网络设备，数据帧要用新的物理层地址重新封装；MAC地址决定了数据帧下一跳哪个地址接收，IP地址决定了数据包的起点和终点；

> 在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有**相同网络地址**的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是`最长匹配`。

### :zap: ARP协议

ARP 地址解析协议，作用是在以太网环境中，数据的传输所依懒的是`MAC地址`而非`IP地址`，而将已知`IP地址`转换为`MAC地址`的工作是由`ARP协议`来完成的。每个主机都会有一个`ARP高速缓存`，里面有所在的局域网上的各主机和路由器的IP地址到硬件地址的`映射表`。

数据包在确定源IP地址与目的IP地址之后，会通过主机的路由表来确定数据包的下一跳的IP地址，但是数据链路层需要的是下一跳的MAC地址，因此借助ARP协议可以完成IP地址到MAC地址的转换，具体过程如下：

- ARP协议借助ARP请求与ARP响应两种包来确定MAC地址；
- 主机通过广播发送ARP请求包，包中含有想知道的MAC地址对应的IP地址；
- 同链路中设备收到ARP请求包后将会解析ARP请求包中的目标IP地址，如果匹配将会返回含有自己MAC地址的ARP响应包给主机；
- 操作系统会建立一个所在局域网上各设备的IP地址到MAC地址的映射表，并会定期清理映射表中的内容；

> RARP协议：ARP协议的逆协议，作用是根据MAC地址转换为IP地址；
>
> 如果是小型嵌入式设备接入网络，则通常需要一台RARP服务器来协助其完成IP设置，服务器中注册该设备的MAC地址与IP地址，然后将该设备接入网络，随后就会发送一条MAC地址到IP地址的RARP请求包，服务器则会将查询到的IP地址通过相应包发送给设备，协助其完成IP地址设置；

### :zap: ICMP协议

ICMP(internet control message protocol)网际控制报文协议，目的是提高IP数据报交付成功的机会。ICMP属于IP层协议，允许主机或路由器报告差错情况和提供有关异常情况的报告，测试网络层有没有故障。

功能：确认IP包是否成功送达目标地址、报告发送过程中IP包被废弃的原因、改善网络设置等；

**ICMP报文格式**

> 首先，ICMP报文是封装在IP包里面的，作为IP包的数据部分存在，是TCP/IP协议中IP协议的助手；

类型（8位）：ICMP查询报文（用于诊断）、ICMP差错报告报文（通知出错原因）

> **查询报文类型：**<类型号-内容>   0-回送应答、8-回送请求
>
> 类型号（8位）：0、8;
> 代码（8位）：0;
> 校验和（16位）：
> 标识符（16位）：用以区分是哪个进程发送的ICMP包，比如使用进程PID作为标识符;
> 序号（16位）：序号从0开始，每发送一次新的回送请求就会加1，可以用来确认网络包是否有丢失;
> 选项数据：具体情况而定，ping会存放发送请求的时间，来计算往返时间；

> **差错报文类型：**<类型号-内容>   3-目标不可达、4-原点抑制、5-重定向或改变路由、11-超时
>
> 类型号（8位）：3、4、5、11
>
> //类型号 3 目标不可达消息
> IP路由器无法将IP数据包发送给目标地址时，返回发送端主机一个目标不可达的ICMP消息
>     在ICMP包头的代码字段中记录具体不可达原因；
>     0-网络不可达；
>     1-主机不可达；
>     2-协议不可达；
>     3-端口不可达；
>     4-需要进行分片但设置了不分片；
> //类型号 4 原点抑制消息
> ICMP原点抑制是为了缓解低速广域线路下，路由器可能会遇到网络拥堵的问题；
>     具体来说就是当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向IP包的源地址发送一个ICMP原点抑制消息；收到该包的主机会增大IP包的传输间隔，减少网络拥堵的状况；
> //类型号 5 重定向消息
> 如果路由器发现发送端使用了非最优路径发送数据，它会返回一个ICMP重定向消息给主机；
>     消息中包含最合适的路由信息和源数据；
> //类型号 11 超时消息
> 如果IP包中的TTL值在当前路由器中减为0，则该IP包被丢弃，并且发送一个ICMP超时消息给发送端主机；

**ping的过程：**

1. 源主机先构建一个ICMP回送请求消息数据包，类型号为8，并且还有序号，每发一个请求数据包，序号自动加1，并且在报文数据部分插入发送时间，以方便计算往返时间RTT；
2. 由ICMP协议将数据包与目的IP地址交给IP层，IP层构建一个协议字段为1的IP数据包；
3. 从本地ARP映射表中查询或者利用ARP协议查询目的MAC地址，通过数据链路层构建一个数据帧并发送出去；

1. 目的端收到数据帧后，查验目的MAC地址，匹配则接收，否则丢弃；
2. 提取数据帧中的IP数据包，IP层检查后将有用的信息提取交给ICMP协议；
3. 目的端主机会构建一个ICMP回送响应消息数据包，类型为0，序号为请求数据包中的序号，发送给源端主机；

- 源端如果在规定时间内没有收到ICMP应答包，则说明目标主机不可达，收到应答包后，会用当前时刻减去数据包发送时刻，得到数据包的延迟；

**traceroute的作用：**

1. 通过故意设置特殊的TTL，来追踪去往目的地时沿途经过的路由器；
2. 利用traceroute可以知道发出的UDP包是否到达了目的主机；
3. traceroute可以通过故意设置不分片，来确定路径的MTU；

### :zap: IGMP协议



### :zap: NAT网络地址转换

专用网连接到因特网的一种地址转换的方式，所有本地主机在和外界通信时都要在NAT路由器上将其本地地址转换为IP才能和因特网连接；

网络地址转换过程：NAT路由器将数据报的源地址IPx转换为全球地址IP6，但是目的地址IPy不会改变，然后发送到因特网；当NAT路由器收到主机Y发回的数据报时，将目的地址IP6根据NAT转换表转换为IPx，最终发给主机X；

### :zap: DHCP协议

DHCP协议用于动态获取IP地址；具体步骤为：（本部分来自小林coding）

- 客户端首先发起 **DHCP 发现报文（DHCP DISCOVER）** 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP **广播**通信，其使用的广播目的地址是 `255.255.255.255`（端口 67） 并且使用` 0.0.0.0`（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。
- DHCP 服务器收到 DHCP 发现报文时，用 **DHCP 提供报文（DHCP OFFER）** 向客户端做出响应。该报文仍然使用 IP 广播地址 `255.255.255.255`，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 **IP 地址租用期**。
- 客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 **DHCP 请求报文（DHCP REQUEST）**进行响应，回显配置的参数。
- 最后，服务端用 **DHCP ACK 报文**对 DHCP 请求报文进行响应，应答所要求的参数。

一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。

如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：

- 服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。
- 服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。

所以在DHCP 交互中**全程都是使用 UDP 广播通信**。

> 对于客户端与DHCP服务器不在同一局域网内的情况，需要用到DHCP中继代理：
>
> - DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以**单播**的形式发给 DHCP 服务器。
> - 服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包转发给 DHCP 客户端 。
>
> 因此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理IP地址。

### :zap: IPv6

地址长度是128位，每16位是一组，中间用冒号‘：’隔开；连续的0可以用两个冒号来折叠，但只能用一次；

**亮点**

- IPv6可以自动设置，即使没有DHCP服务也可以实现IP地址的自动分配；
- IPv6 包头包首部长度采用固定的值 `40` 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大**提高了传输的性能**。
- IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大**提升了安全性**。

---

## :three: 传输层

两个重要协议：TCP、UDP
传输控制协议TCP：需要将要传输的文件分段传输时，编号；就需要TCP协议来建立会话实现可靠传输；同时也有流量控制功能。(例如QQ传文件)
用户数据报协议UDP：一个数据包就能完成数据通信；不需要建立会话和流量控制；多播/广播；是一种不可靠传输。(例如QQ聊天，屏幕广播)

TCP/UDP协议+端口号=对应的应用层协议
常用的应用层协议：
http = TCP + 80          Https = TCP + 443                  RDP = TCP + 3389
ftp = TCP + 21            共享文件夹 = TCP + 445         SMTP = TCP + 25
POP3 = TCP + 110     telnet = TCP + 23                    SQL = TCP + 1433
DNS = UDP + 53

传输层协议与网络层协议的区别：
网络层协议实现的是如何把数据报从一个地址（服务器/主机）发送到另外一个地址（服务器/主机），实现的是主机之间的逻辑通信；
传输层实现的是如何让应用程序找到对应计算机的应用程序，也就是实现应用程序之间的逻辑通信；

传输层的主要功能：
(1)传输层为应用进程之间提供了端到端的逻辑通信(但网络层是为主机之间提供逻辑通信)。
(2)传输层还要对收到的报文进行差错检验。
(3)传输层提供面向连接(TCP)和无连接(UDP)的服务。

### **:zap: UDP协议**

(1)UDP是无连接的，即发送数据之前不需要建立连接。

(2)UDP使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。

(3)UDP是面向报文的，适合多媒体通信的要求。

(4)UDP支持一对一，一对多，多对一，多对多交互通信。

(5)UDP首部开销小，只有8个字节。

**UDP首部格式**

首部仅8个字节，包括源端口、目的端口、长度（首部+数据部分）、检验和；
另外还包括一个12字节的伪首部，用于检验和；
计算UDP检验和：两个字节为一组，进行二进制反码求和，将得到的结果再求反码，就是检验和；

两个对等运输实体在通信时传送的数据单位叫做 运输协议数据单元TPDU;
TCP传送的TPDU叫做TCP报文段；
UDP传送的TPDU叫做UDP报文或用户数据段；



### :zap: TCP协议

(1)TCP是面向连接的传输层协议，通过三次握手来建立连接；
(2)每一条TCP连接只能有两个端点(endpoint)，也就是只能点对点的通信。
(3)TCP提供可靠交付的服务，确保不丢包；
(4)TCP提供全双工通信，因为需要接收端的反馈，例如如果接收端处理不过来，可让发送端慢一点，也就是流量控制；
(5)面向字节流。
(6)如果要传输一个比较大的数据，首先一次只会传输一小块，这个数据块的大小是没有规律的。加上数据包数据帧的头，发送给接收端，接收端去掉首部，再次拼接。

**TCP的连接**

(1)TCP把连接作为最基本的抽象。
(2)每一条TCP连接有两个端点。
(3)TCP连接的端点不是主机，不是主机的IP地址，不是应用程序，也不是传输层协议端口，TCP连接的端点叫 套接字(socket).
->套接字socket = (IP地址:端口号)
->每一条TCP连接唯一地被通信两端的两个套接字所确定，即：
->TCP连接 ::= {socket1, socket2} = {(IP1:port1), (IP2:port2)}
(4)端口号拼接到IP地址即构成了套接字。

**TCP的可靠传输**

<u>1、停止等待协议（ARQ）</u>
停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。
全双工通信的双方既是发送方也是接收方。
在发送完一个分组之后，必须暂时保留已发送的分组的副本，同时还存在超时重传和编号机制，超时计时器的重传时间应该比数据在分组传输的平均往返时间更长一些；分组和确认分组都必须进行编号；
->使用上述的**确认和重传机制**，就可以在不可靠的传输网络上实现可靠的通信。
->这种可靠传输的协议常称为**自动重传请求ARQ(Automatic Repeat reQuest)**。
->ARQ表明重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。
->缺点，信道利用率低。

超时重传时间的确定：RTTs(new) =  (1 - alpha) x (RTTs(old)) + alpha x (new RTT样本)      alpha一般取0.125；超时重传时间应略大于上面得出的加权平均往返时间RTTs。这个公式的目的是根据网速和带宽的实时情况调整往返时间。

<u>2、连续ARQ协议</u>
发送方一次可以发出多个分组。使用`滑动窗口协议`控制发送方和接收方所能发送和接收的分组的数量和编号。
每收到一个确认，发送方就把`发送窗口向前滑动`。接收方一般采用`累积`确认的方式。采用`回退N`（Go-Back-N）方法进行重传。优点：容易实现，信道利用率高。缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。

<u>3、以字节为单位的滑动窗口技术</u>

发送窗口的长度是由接收窗口长度决定的；
在没有收到B端的确认收到之前，A端不能删掉滑动窗口中的内容；
A可以持续发送数据给B，直到A的滑动窗口内的数据都发送了；
B收到后给A发确认收到的反馈ACK，序号是下一个应该发送的字节的序号，A收到后，就可以滑动窗口到对应的位置。例如B反馈ACK是7，那么A的滑窗可以移动到7位置，1-6删除。21-26可以发送。B收到1-6之后，也开始滑窗，B的应用程序可以读取1-6的数据。B的滑窗继续接收。

以段为单位发送数据包，每发送一个数据包需要等待一个ACK信号，当数据包往返时间越长效率越低。滑动窗口中窗口前端为已发送但为收到ACK的数据，后端为待发送数据。发送端一次发送多个数据，接收端回传收到的连续数据的ACK信号，缓存缺失数据之后的数据包(保持顺序)。发送端当收到ACK信号时，窗口向前依次移动，直到遇到有数据未确认时停止。一段时间后启动超时重传，接收端若收到缺失数据，则和缓存数据一起发送ACK信号，否则，抛弃缓存数据。

<u>4、流量控制</u>

解决通信两端处理时间不一样的问题。通过实时调整滑窗尺寸的大小(尺寸甚至可以是0)来实现流量控制。接收端主动调整滑窗大小，发送端根据接收端发送的报文调整相应的滑窗。发送端也会定时发送报文向接收端确认滑窗信息，避免接收端发送的相关调整滑窗大小的报文丢失带来的影响。

流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

<u>5、避免网络拥塞</u>

出现资源拥塞的条件：对资源需求的总和 > 可用资源；因此拥塞控制是一个全局性的过程，涉及到所有的主机和路由器，以及与降低网络传输性能有关的所有因素；

解决方法：采用**慢开始、拥塞避免、快重传、快恢复**的策略，

(1)发送方维持 拥塞窗口cwnd(congestion window)
(2)发送方控制拥塞窗口的原则是：
只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去；
只要网络出现拥塞，拥塞窗口就减少一些，以减少注入到网络中的分组数。
(3)慢开始算法的原理
由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
(4)设置慢开始门限状态变量ssthresh
慢开始门限状态变量ssthresh的用法如下：
当cwnd<ssthresh时，使用慢开始算法；
当cwnd>ssthresh时，停止使用慢开始算法，改用拥塞避免算法；
当cwnd=ssthresh时，使用慢开始算法或拥塞避免算法均可；
(5)拥塞避免算法的思路
让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd按线性规律缓慢增长。
(6)当网络出现拥塞时对策
无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(其根据就是没有按时收到确认)，就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半(但是不能小于2)。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间吧队列中积压的分组处理完毕。

快重传与快恢复：当发送端收到连续三个重复的确认时，就执行“乘法减少”算法，即把慢开始门限ssthresh减半，但拥塞窗口cwnd现在不设置为1，而是设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法(“加法增大”)，使拥塞窗口缓慢地线性增大。

发送窗口的大小取 接收方窗口和拥塞窗口二者中的最小值；

**TCP报文段格式**

TCP的首部分为  20字节固定长度的首部+长度可变的选项和填充；
(1)源端口：2个字节16位。
(2)目的端口：2个字节16位。
(3)序号：当前数据的第一个字节在整个文件中的序号。
(4)确认号ack：接收端发送，提示发送端下一次该发的数据在整个文件中的序号。接收端收到后，会把这个序号之前的数据从缓存中删掉。
(5)数据偏移：当前TCP报文段第多少个字节后是TCP的数据部分了。数据偏移最多表示1111，即15，他最多可以表示15乘以4，即60个字节的偏移量，所以选项+填充最多只能是40个字节。（这里一个1表示的是4）
(6)保留：6位，无作用。
(7)URG：urgent，意思是优先级高，发送端优先发送，而不是在缓存中排队。
(8)ACK：acknowledge，1意味着确认建立了会话。
(9)PSH：1意味着接收端优先读取，而不是在缓存中排队。
(10)RST：reset，1意味着TCP会话出现严重错误，必须释放和重新连接。
(11)SYN：同步。1意味着要发起会话。
(12)FIN：finish，1意味着释放连接。
(13)窗口：接收端先发，发送端根据接收端的窗口尺寸确定发送端窗口尺寸。
(14)检验和：
(15)紧急指针：只有URG为1才有用。

**TCP传输连接管理**

TCP的连接采用客户服务器方式，主动发起连接的应用程序叫客户，被动等待连接的叫做服务器

<u>三次握手建立连接</u>：

1、客户端、服务端均处于CLOSED状态，其中服务端会主动监听某个端口，处于LISTEN状态；

2、客户端主动发起连接请求SYN；

3、服务端收到连接请求，返回SYN，同时ACK客户端的SYN；

4、客户端收到SYN和ACK之后，发送ACK的ACK，然后状态变为ESTABLISHED状态；

5、服务端收到ACK之后，状态转换为ESTABLISHED状态；



具体过程：

第三次握手原因：假如把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机A和B之间的通信，假定A给B发送一个连接请求分组，B收到了这个分组，并发送了确认应答分组。按照两次握手的协定，B认为连接已经成功地建立了，可以开始发送数据分组。可是，B的应答分组在传输中被丢失的情况下，A将不知道B是否已准备好，A认为连接还未建立成功，将忽略B发来的任何数据分组，这样就形成了死锁。



<u>四次挥手释放连接</u>

具体过程：













## :four: 应用层





### :zap: DNS协议

DNS域名解析协议就是将域名地址转换为IP地址；

域名层级之间靠句点`"."`来分割，越靠右边的域名层级越高；

- 域名层级关系：
  - 根DNS服务器
  - 顶级域DNS服务器
  - 权威DNS服务器
- 工作流程：
  - 客户端发送DNS请求，发送给本地DNS服务器；
  - 本地域名服务器：如果能够在缓存表中找到域名的IP地址，则直接返回IP地址；如果没有，本地DNS会发送信息到根域名服务器；
  - 根DNS服务器：根据域名给出顶级域名服务器地址，并发送给本地域名服务器；
  - 本地域名服务器收到地址后发送信息给顶级域名服务器；
  - 顶级域名服务器将权威域名服务器地址发送给本地域名服务器；
  - 本地域名服务器发送信息给权威域名服务器；
  - 权威域名服务器将IP地址发送给本地域名服务器；
  - 本地域名服务器将IP地址返回给客户端；

## :ballot_box_with_check: 问题：

#### 1、一个数据报在网络中传输的过程

类似：键入网址后到网页的显示，期间发生了什么？

浏览器解析URL->生成发送给Web服务器的请求信息（HTTP请求信息）->查询服务器域名对应的IP地址（DNS）->协议栈->TCP/UDP协议->IP协议（ICMP 、ARP协议）->

- MTU与MSS
  - MTU：一个网络包的最大长度，以太网中一般为 `1500` 字节。
  - MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

![image-20200730220157741](C:\Users\Jianlin Song\AppData\Roaming\Typora\typora-user-images\image-20200730220157741.png)

- 如果客户端有多个网卡，就会有多个IP地址，数据报发送的源地址应该如何选择？

  > 通过目的IP地址与IP地址的子网掩码进行与运算，如果得到的结果是匹配的，那么就选择对应的IP地址为源地址，如果所有IP地址都无法匹配，那么最终将将会与默认网关匹配。