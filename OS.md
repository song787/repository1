## 操作系统

[TOC]

---

### **1\ 概念**

#### **操作系统内核的基本特征**

- 并发：计算机系统中同时存在多个运行的程序，需要操作系统的管理和调度；
- 共享：同时访问，互斥共享
- 虚拟：利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务；
- 异步：程序的执行不是一贯到底，而是走走停停的，并且向前推进的速度不可知，但是只要运行环境相同，操作系统需要保证程序运行的结果也要相同；

#### **操作系统对外设与应用程序的服务**

- 系统调用：应用程序请求操作系统提供服务；
- 异常：应用程序意想不到的行为；
- 中断：由外部事件引起；

#### **系统调用**



#### 用户态与内核态



·

### 2\ 进程与线程

- 进程：进程是系统进行资源分配的基本单位，进程的基本信息与状态由进程控制块PCB来描述；

  - 程序 = 算法 + 数据结构（描述进程的数据结构：进程控制块PCB） 

- 线程：线程是CPU调度的基本单位，是进程当中的一条执行流程，同时线程依赖于进程存在，一个进程至少有一个线程存在；`线程=进程-共享资源`

  - 线程能够减少并发执行的时间和空间开销：
    - 线程的创建时间比进程短；
    - 线程的终止时间比进程短
    - 同一进程内的线程切换时间比进程短
    - 由于同一进程的各线程之间共享内存和文件资源，可直接进行不通过内核的哦通信；

- 区别：
  - 进程是系统资源分配的基本单位，因此线程只拥有一点再运行中必不可少的资源，如程序计数器、寄存器、栈等，其余的资源需要访问隶属进程的资源；
  
  - 线程是CPU调度的最小单位，因此同一个进程中的线程切换只需要保存和设置少量的寄存器内容，而不属于同一个进程的线程之间的切换，涉及到进程切换，需要当前执行进程CPU环境的保存及新调度进程CPU环境的设置，相对来说进程切换的开销远大于线程切换的开销；`线程有自己的寄存器和堆栈`
  
  - 通信方面，线程之间的通信可以通过同一进程中的共享数据通信，而进程之间的通信需要借助IPC；
  
  - 稳定性方面，多线程程序如果有一个线程对共享数据造成破坏或崩溃，会影响整个程序，导致崩溃，但是在多进程程序中，进程间是相互独立的，一个进程出错或崩溃不会导致整个程序崩溃，所以在稳定性和健壮性方面，多进程更好；`进程更安全，但是慢一点，线程快，性能好，但是不够安全`
  
    

#### **进程的状态**

`进程创建、进程运行、进程阻塞、进程就绪、进程结束`

就绪状态：

执行状态：

阻塞状态：

**进程状态变化模型**



`线程同样拥有就绪、执行、阻塞三个状态，拥有同样的状态转换关系`

#### **进程调度算法**

`上下文切换：停止当前运行进程并且调度其他进程`

`吞吐量：操作系统的计算带宽`

1. 批处理系统：
   - 先来先服务FCFS：如果进程在执行中阻塞，那队列中的下一个会得到CPU；
     - 优点：简单
     - 缺点：
       - 平均等待时间波动较大；
       - 花费时间少的任务可能排在花费时间长的任务后面
   - 最短作业优先SJF：按照预测的完成时间来将任务入队；（非抢占）
     - 优点：最优平均等待时间
     - 缺点：
       - 可能导致饥饿（连续的短任务可能会使长任务饥饿）
       - 需要预知未来：需要预估下一个 CPU突发的持续时间
   - 最短剩余时间优先SRT：（可抢占）
   - 最高响应比优先HRRN：在SJF的基础上，考虑到了饥饿现象（不可抢占、关注进程等待了多长时间、防止无限期推迟）
     - R = (w + s) / s，选择R值最高的进程进入CPU，w是等待时间、s是执行时间；
     - 缺点：不可抢占、同样需要执行时间s，所以难以获得精确的时间，只能预估；
2. 交互式系统
   - 时间片轮转RR：在一个叫做时间切片的离散单元中分配处理器，如果时间片结束了，那么就切换到下一个准备好的进程；
     - 轮循的花销主要在于额外的上下文切换；
     - 缺点：
       - 如果时间片太大，则等待时间过长，极限情况下退化为FCFS；
       - 如果时间片太小，则反应迅速，但是上下文切换的开销较大，导致吞吐量受到影响；
   - 优先级调度算法：
   - 多级反馈队列调度算法MFQ：
     - 兼顾轮询RR和最短剩余时间优先SRT的优点，将就绪队列划分为独立的队列，每个队列有自己的调度策略，调度必须在队列间进行，固定的优先级（可能导致饥饿），时间切片（每个队列都得到一个确定的能够调度其进程的CPU总时间）；
     - 对于IO密集型任务，放在高优先级队列，这里的时间片比较短，对于CPU密集型任务，放在低优先级队列，这里的时间片比较长，考虑到交互性，占用资源多的可以放在后面，一个进程可以在不同的队列中移动；

#### 进程同步

`同步问题的产生，主要是因为存在共享资源，当多个线程或进程读写同一份共享资源时，可能会导致冲突，所以利用同步的方式让多个线程能够按顺序访问资源；`

- 临界区：一段对临界资源访问的代码，称为临界区；临界区只允许同时一个线程对其访问，如果同时有其他线程试图访问临界区，会被挂起，直到临界区中的线程退出临界区；`临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域.`

- 互斥量Mutex：互斥量是一个内核对象，是访问互斥资源的一把钥匙，并且钥匙只有一把，只有拥有互斥量的线程才能够访问互斥资源，只有该线程访问结束才会交出互斥量，因此可以保证互斥资源不会被多个线程同时访问；（一个房间只有一把钥匙，每个拥有钥匙的人进门后就要反锁房间，别人就不能进入房间，只有房间里的人访问完房间出来后，才会交出钥匙，下一个人才能够访问房间；）

- 信号量Semaphore：
  - 信号量是一个整型变量sem，包含两个原子操作P( )、V( )，也就是对信号量的-1和+1操作；
  - 当一个线程访问临界区，信号量为正，则可以进行P操作，如果信号量等于0，则线程睡眠，等待信号量大于0；如果一个线程完成了对临界区的访问，会对信号量执行V操作，信号量+1，同时会唤醒睡眠的线程；
  - 信号量是被保护的变量，在初始化完成后，唯一改变一个信号量的值的办法就是通过P、V操作；
  - P操作能够产生阻塞，V操作不会阻塞；
  - 信号量允许同一时刻多个线程访问同一资源，最大线程数量不超过信号量的最大资源计数；
  - 如果信号量的最大资源计数为1，也就是只能取0和1，那么信号量就成了互斥量；
  
  **有界缓冲区的生产者-消费者问题**：（待整理）
  
  
  
- 管程：（待整理）

  - 

##### 经典同步问题（待整理）

​	**哲学家就餐问题**：

​	**读者-写者问题：**

#### 进程间通信IPC

`消息传递可以是阻塞或者非阻塞的，阻塞的消息被认为是同步的，非阻塞的消息被认为是异步的`

- 管道pipe：通过父进程帮子进程建立好的通道实现
  - 子进程从父进程继承文件描述符；
- 命名管道：（待整理）
- 信号：软件中断通知事件处理；
  - 接收到信号时会发生什么：
    - catch:指定信号处理函数被调用；
    - ignore:依靠操作系统的默认操作；
    - mask:闭塞信号，因此不会传送；
  - 缺点：不能传输要交换的任何数据；
- 信号量：（待整理）
- 消息队列：消息队列按照FIFO来管理消息；
- 共享内存：（直接通信模式）
  - 每个进程都有私有地址空间，在每个地址空间内，明确的设置了共享内存段；
  - 优点：快速、方便的共享数据
  - 缺点：必须同步数据访问，以免产生冲突；
  - 这是最快的进程间通信方法，并且一个进程写，另一个进程立即可见，没有系统调用干预，没有数据的复制，但是共享内存不提供同步，需要程序员来提供；
- 套接字：（待整理）

#### 协程(待整理)



#### 僵尸进程（待整理）





### 3\ 死锁问题

---

`在一组阻塞的进程持有一种资源，等待获取另一个进程所占有的一个资源`

- 发生死锁的条件
  - 互斥：在一个时间只能有一个进程使用资源；
  - 持有并等待：进程保持至少一个资源正在等待获取其它进程持有的额外资源；
  - 无抢占：一个资源只能被进程自愿释放，不能被抢占；
  - 循环等待：多个进程组成了一条环路，循环等待下一个进程所持有的资源；`死锁必有环，有环不一定死锁`
- 死锁的处理方式
  - **鸵鸟策略**：忽略死锁问题；

  - **死锁避免** `确保系统永远不进入不安全状态`

    ​	**安全状态**：

    - 需要系统具有一些额外的先验信息提供，最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目；
    - 资源的分配状态是通过限定`提供与分配的资源数量`和`进程的最大需求`；
    - 死锁避免算法动态检查资源分配状态，以确保永远不会有一个环形等待状态（不安全状态）；
    - 当一个进程请求可用资源，系统必须判断立即分配 是否能使系统处于安全状态；

  - **死锁预防**  `至少破坏一个产生死锁的条件`
    
    - 互斥：
    - 持有并等待：需要进程请求并分配其所有资源，它开始执行之前或允许进程请求资源 仅当 进程没有资源时；`资源利用率低，可能导致饥饿`
    - 无抢占：如果进程占有某些资源，同时请求其它不能被立即分配的资源，那么就释放当前正占有的资源，将被抢占资源添加到资源列表中，只有当它能够获得旧的资源以及它请求的新的资源，进程才能得到执行；
    - 循环等待：对所有资源类型进行排序，并要求每个进程按照资源顺序进行申请；
    
  - **死锁检测恢复**
    
    - 死锁检测算法
    
    - 利用抢占恢复
    - 利用回滚恢复
    - 通过杀死进程恢复

### 4\ 内存管理

---

**连续内存分配与非连续内存分配对比：**

- 连续内存分配的缺点：
  - 内存的利用率较低；
  - 有外碎片、内碎片的问题
- 非连续分配的优点：
  - 更好的内存利用和管理；
  - 允许共享代码与数据；
  - 支持动态加载与动态链接

**应用程序的逻辑地址是如何映射到物理地址的？**



#### 虚拟内存

每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。虚拟内存让程序可以获得更多的可用内存；（虚拟内存-逻辑地址、物理内存-物理地址）

#### 分段

程序由若干个逻辑分段构成，有代码段、数据段、堆段、栈段。

**分段寻址方案**：

- 逻辑地址空间分散到多个物理地址空间，逻辑地址由一个二维的二元组构成，分别是段号和段内偏移量；
- 其中段号用作段表的索引，段表里面保存的是这个段的基地址、段的界限和特权等级等；
- 段内偏移量的合法值应该为0至段界限，如果合法，那么物理地址 = 段基地址 + 段内偏移量；

**存在的问题：**

- 有内存碎片问题：
- 内存交换效率低问题：为了不连续的内存碎片腾位置，需要借助硬盘来实现内存区域的整理，而硬盘的读写速度远远慢于内存，因此效率低下；

#### 分页

分页是把整个逻辑地址空间和物理地址空间切割成一段段固定尺寸的区域，这样一个连续并且尺寸固定的内存空间，称为页，Linux下每页大小4KB；

**分页寻址方案：**

- 逻辑地址 与 物理地址 之间通过页表来映射；
- 页表 存储在CPU的内存管理单元MMU中，所以CPU可以直接通过MMU找到要实际访问的物理地址；

- 通过页号去找帧号，最后形成物理地址；`页 是连续的虚拟内存，帧 是非连续的物理内存，不是所有的页都有对应的帧`

- 当进程访问的逻辑地址在页表中查不到时，就会产生一个缺页中断，此时会进入系统内核空间分配物理内存，更新进程页表，最后再返回用户空间，恢复进程的运行；

  `逻辑地址分为两部分：页号、页内偏移量，页号是页表的索引，页表中页号对应的是物理页帧的基地址，通过基地址与页内偏移量的组合就可以形成物理内存地址；`

**分页解决了分段存在的两个问题：**

- 采用分页，每次释放的内存都是以页为单位释放，不会产生无法给进程使用的小内存；
- 分页在内存-硬盘的换入-换出中，一次性写入硬盘的只有少数的页，效率相对较高；同时分页实现了程序运行中，需要用到对应虚拟内存页中的指令和数据时，再加载到物理内存中，进一步提升了效率；

**存在的问题：**

简单分页可能存在空间上的缺陷，每个进程都会有一个独立的页表，32位环境下，每个页表需要4MB内存来存储，当进程数量非常多时，需要非常多的内存来存储页表；（用多级页表来解决该问题，而多级页表带来的地址转换工序复杂问题，可以由页表缓存TLB来解决，把常访问的几个页表项存储到访问速度更快的硬件，利用MMU完成地址转换和TLB的访问交互，在寻址时，先查TLB，再查常规页表）

#### **页面置换算法**

- 最优页面置换算法OPT
  - 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。
- 最近最久未使用LRU
  - 虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。
  - 为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。
  - 因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。
- 最不常用算法LFU
- 最近未使用NRU（时钟页面置换算法Clock）
  - 
- 先进先出FIFO

#### 段页式

#### 分段与分页的比较

### 5\ 磁盘调度

---

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的`平均寻道时间最短`

#### 1\ 先来先服务

> FCFS, First Come First Served

按照磁盘请求的顺序进行调度。

优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

#### 2\ 最短寻道时间优先

>  SSTF, Shortest Seek Time First

优先调度与当前磁头所在磁道距离最近的磁道。

虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

#### 3\ 电梯算法

> SCAN

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。





**参考文献：**

[1] [wolverinn](https://github.com/wolverinn)/**[Waking-Up](https://github.com/wolverinn/Waking-Up)**

[2] [CyC2018](https://github.com/CyC2018)/**[CS-Notes](https://github.com/CyC2018/CS-Notes)**

[3] [chyyuu](https://github.com/chyyuu)/**[os_course_info](https://github.com/chyyuu/os_course_info)**

[4] 公众号:小林coding - [20张图直接把操作系统内存管理部分安排了](https://mp.weixin.qq.com/s/m-AmxDVUfko7OTUsCapnPA)

 