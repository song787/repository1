







## 一、类的问题

#### 封闭类

封闭类：类的成员属性为其他类的对象，这种类称为封闭类，这个成员属性称为成员对象；

封闭类要注意构造问题，因为涉及成员对象的构造；

封闭类在执行拷贝构造的时候，成员对象也会执行拷贝构造；

#### 构造与析构的顺序

- 对于封闭类，先构造成员对象，再构造封闭类，先析构封闭类对象，再析构成员对象；成员对象的构造顺序与声明顺序一致；
- 对于基类-派生类，在声明派生类对象的时候，先构造基类，再构造派生类，析构时先析构派生类，再析构基类；

#### 继承

- 三种继承方式，public、protected、private，无论哪种方式，派生类都会继承得到基类的所有成员变量与成员函数，但是派生类无法访问基类的`private`成员；

  |  继承方式   |             继承得到的成员的权限             |
  | :---------: | :------------------------------------------: |
  |  `public`   |  `public->public` \ `protected->protected`   |
  | `protected` | `public->protected` \ `protected->protected` |
  |  `private`  |   `public->private` \ `protected->private`   |

- 派生类对象的大小 = 基类成员变量大小 + 派生类成员变量大小；

- 两个类可能拥有的关系：继承、复合；

- 父类指针指向子类对象时，指针类型仍然是父类对象，因此可以通过指针访问其public成员，访问结果是子类重写父类虚函数的结果，但是指针不能访问子类中非继承的成员（必须将指针强转之后才能访问）；

#### 多态

基类指针（引用）指向派生类的对象，通过指针可以调用基类、派生类中的同名虚函数，如果指针指向基类，则调用基类的虚函数，如果指针指向派生类，则调用派生类的虚函数。

---

- 如果不想编译器自动生成函数，可将相应的成员函数声明为 `private` 并且不予实现。使用像 Uncopyale 这样的基类也是一种做法。
- 在构造和析构期间不要调用虚函数，因为基类构造期间，虚函数绝不会下降到派生类阶层，也就是说这时候的虚函数不是想要的虚函数；

- 编译器默认对一个类生成的四个函数中，赋值操作符函数可能会存在编译器拒绝生成的情况：
  - 如果成员对象中内含引用，就会出现引用对象修改的问题，不合法；
  - 如果有包含`const`的成员对象，那么会出现更改`const`成员的问题，不合法；
  - 如果基类将`operator=`函数声明为`private`，那么编译器将拒绝为其派生类生成`operator=`函数；
  - 另外，如果成员对象包含指针，那么默认的operator=是浅拷贝，需要手动将其实现为深拷贝；

- 初始化问题：
  
- 为避免“跨编译单元之初始化次序”的问题，需要以`local static` 对象替代`non-locol static`对象.也就是将每个`non-local static`对象搬到自己的专属函数内（该对象在此函数内被声明为`static`），这个专属函数就是一个取得新的对象的接口，这个对象用`static`修饰，就可以保证即使用完了析构了，这个对象也还是存在的；专属函数的返回是一个引用，指向它所含的对象；
  
- **成员初值列**相较于构造函数，效率较高，原因在于一般的构造函数中，是先调用成员对象的默认构造函数，然后紧接着进行赋值操作，经历两个步骤；而成员初值列只发生一次拷贝构造；

  - 初始化次序，先是基类对象，再初始化派生类对象；
  - 在类里成员变量总是以声明次序被初始化，否则会出现编译出错；

- 

  





## 二、关键字问题

#### const关键字

- 常量对象，声明对象时在前面加const；
- 常量成员函数：在类的成员函数后面加const关键字；
  - 常量成员函数不能修改成员变量的值；（静态成员变量）
  - 常量成员函数不能调用一般成员函数；（静态成员函数）
  - const可以作为重载的条件；
- 常引用：在引用前加const关键字；
  - 不能通过常引用修改引用对象的值；`引用就是地址传递，很容易通过引用修改了对象的值，加const可以让引用变为对象的一个只读接口`
  
  - 利用常引用作为函数参数，可以防止引发拷贝构造`(拷贝构造一个临时对象，类似于值传递，徒增开销)`，同时又可以避免形参误修改实参；
  
    ```c++
    const T& a 的方式传递对象，减少一次拷贝构造，可以提升效率
    ```
  
- 可以利用const，在const和non-const成员函数中避免代码重复；（令non-const版本调用const版本）





## 三、重载、重写、重定义

#### 重载

##### 运算符重载

- 解决自定义对象无法使用预定义运算符进行运算的问题；

  ```c++
  返回值类型 operator 运算符(形参表){ }
  ```

- 赋值运算符只能重载为成员函数；

  - 如果存在指针成员变量，那么还要考虑的浅拷贝、深拷贝问题，让等号的左值对象与右值对象中的指针成员变量不是指向同一块内存；默认下是浅拷贝，所以会出现问题，要利用赋值运算符重载实现深拷贝；

  - 赋值运算符重载的返回值一般是引用的形式；

    ```c++
    T& operator=(const T& rhs){
    	...
    	return *this;
    }
    ```

  - 要考虑到赋值运算符给自己赋值的问题，要规避因此带来的问题

    - 如果是指针类对象，那么在一开始delete this->date的时候，如果是自我赋值，那么就会把形参的date一起delete掉，后面的赋值也就变成了赋值为了一个被销毁的对象；

    - 可以通过if语句实现判断，但并不是最好的，不具备安全性；

    - 更好的方式是采用copy and swap 技术：(使用swap就可以避免new的开销，swap是交换指针的所有权，开销比较小)

      - ```c++
        class A
        {
        	...
        	void swap(A& rhs) // 交换*this 和 rhs 的数据
        	{
        		using std::swap;
        		swap(pb, rhs.pb);
         	}  
        	... 
        private:
            B * pb; // 指针，指向一个从堆分配而得的对象
        };
        A& A::operator=(const A& rhs)
        {	
            A temp(rhs); // 为 rhs 制作一份复件（副本）
        	swap(tmp);   // 将 *this 数据和上述复件的数据交换。
        	return *this;
        }
        ```

- ++运算符重载

  - 实现前置++重载；返回值为T&
  - 后置++利用前置++实现；返回值为T
  - 后置运算符重载在执行步骤上要多一个临时变量的生成与赋值；因此前置运算符的重载函数比后置运算符的重载函数性能更高，开销更小；

- 输入输出流运算符的重载：重载ostream类的`<<`运算符和istream类的`>>`运算符，并且只能重载成全局函数；



##### 函数重载





#### 重写





#### 重定义







#### 静态存储区

```c++
#include<iostream>
using namespace std;

int main(){
       
    static int a;//全局静态变量 
    
    void print(int& a){
        static int b;//局部静态变量
        cout<<b<<endl;
    }
    
    static int sum(int& a, in& b){//静态函数
        return a+b;
    }
    
    animal::eat();
    
    }   
    return 0;
}

class animal{
public:
    animal(){};

    static weight;//类的静态成员，不再属于对象

    static void eat(){//类的静态函数，不再属于对象
        //不可以引用类中的非静态成员
        cout<<"eat"<<endl;
    }
```



#### 指针数组与数组指针

```c++
#include<iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;

int main(){

    //测试变量1--字符串常量、指针数组（数组）
    char aa[] = "hello";  //字符串常量
    char const *arr[] = {"aaa","bbb","cfs","ddd"}; //指针数组，是一个数组，每个元素是一个指针；想象成(char*) arr[];

    //测试输出1
    cout << "aa[2]: " << aa[2] << endl; // 'l'
    cout << "aa: " << aa << endl;  //hello
    cout << "*aa: " << *aa << endl;  //'h'
    
    cout << "arr[2]: " << arr[2] << endl; // ccc
    cout << "*arr[2]: " << *arr[2] << endl;  //'c'
    cout << "&arr[2]: " << &arr[2] << endl;  // &ccc
    cout << "*arr: " << *arr << endl;  // aaa
    cout << "&arr: " << &arr << endl;  // &aaa
    cout << "&arr[0]: " << &arr[0] << endl;  // &aaa
    cout << "arr: " << arr << endl;  //&aaa
	//
    
    cout << "------------------------------------" << endl;
    cout << "------------------------------------" << endl;

    //测试变量2--数组指针（指针）

    int(*arrPtr)[10] = NULL;   // 数组指针，一个指针，它指向一个有10个int元素的数组
    int matrix[3][10] = { 0 };  
    arrPtr = matrix;

    (*arrPtr)[0] = 5;
    matrix[2][9] = 6;
    arrPtr++;
    (*arrPtr)[1] = 7;

    //测试输出2
    for(int i = 0;i < 3;i++){
        for(int j = 0;j < 10;j++)
            cout << matrix[i][j] << " ";
        cout << endl;
    }
    /*
    5 0 0 0 0 0 0 0 0 0
    0 7 0 0 0 0 0 0 0 0
    0 0 0 0 0 0 0 0 0 6
    */

    cout << "------------------------------------" << endl;
    cout << "------------------------------------" << endl;
	
    //测试变量3--字符指针
    char const *ptr = "C language"; 
    cout<<"ptr: " <<ptr<<endl;        //ptr: C language
    cout<<"ptr[3]: " <<ptr[3]<<endl;  //ptr[3]: a
    ptr += 2;
    cout<<"ptr+2: " << ptr <<endl;    //ptr+2: language
	//字符指针与字符数组的区别：
    //1、占用空间不同。数组所占空间取决于数组的长度，而指针只占用4字节，用以存放字符串的首地址。
    //2、赋值方式不同指针本身是变量，所以可以这样char *ps; ps = "C language!"; 赋值，
    //而数组不能这样char A[20];A = "C language!;赋值，而要逐个赋值。
    
    return 0;
}
```



#### C++程序内存管理



**BSS段（未初始化数据区）：**

**数据段（已初始化数据区）：**

**代码段：**









## 五、C++11新特性

#### 右值引用



#### 引用折叠



#### lambda表达式



#### enum枚举



#### RAII

> RAII守则：资源在构造期间获得，在析构期间释放；

- 复制 RAII 对象必须一并复制它的所管理的资源（深拷贝），所以资源的 copying 行为决定 RAII 对象的 copying 行为。
- 普通而常见的 RAII class copying 行为是：禁止 copying、执行引用计数法。

#### 智能指针

对于动态分配（new）在堆中的对象，指针对象离开了作用域并不会自动调用析构函数，需要手动delete，为了让指针对象能够像普通对象一样，离开作用域自动调用析构函数回收资源，需要借助智能指针的特性；

> 以对象管理资源：获得资源后立刻放进管理对象内（智能指针），管理对象运用析构函数确保资源释放；

##### :dagger: ​std::auto_ptr(C++98提供、C++11建议摒弃不用)

```c++
void func(){
	std::auto_ptr<A> ptr (createA());  //建立了一个指针对象
	... //正常使用ptr
}  //离开作用域，由auto_ptr 的析构函数自动删除ptr；
```

避免了func()函数潜在的资源泄露的可能性；

`auto_ptr` 存在的问题：如果进行了赋值操作或者拷贝构造，原指针会变成`null`，新的指针将获取资源的唯一拥有权；

##### :dagger: std::unique_ptr

unique_ptr同样采用所有权模型，但是该指针禁止赋值操作或拷贝构造，如果进行这些操作会编译出错；

##### :dagger: std::shared_ptr     

shared_ptr在使用拷贝构造或者赋值操作后，引用计数会累加，并且两个指针对象指向的是同一块内存（类似于浅拷贝），当一个对象离开作用域，shared_ptr会把引用计数值-1，直到引用计数值为0时，才会进行删除对象，由于shared_ptr释放空间时会先判断引用计数值的大小，因此不会出现多次删除同一块内存的现象（也就是浅拷贝中重复析构的问题）。

##### 从智能指针获取原始指针

**显式转换**：利用get成员函数

```c++
std::shared_ptr<T> ptr(creatA());
void func(const T* ptr);

func(ptr.get());
```

**隐式转换：**通过智能指针重载的取值操作符（`*`和`->`）

```c++
class T{
    public:
    bool isExist() const;
};
std::shared_ptr<T> ptr(creatA());

ptr->isExist();
(*ptr).isExist();
```



## 六、零碎问题

- 对于单纯常量，最好以`const`对象或 `enum` 替换 `#define`；对于形式函数的宏，最好改用 `inline` 函数替换`#define`；

- Copying 函数（复制构造函数和赋值操作符函数）应该确保复制「对象内的所有成员变量」及「所有 base class（基类） 成分」。

  不要尝试以某个 copying 函数实现另外一个 coping 函数。应该将共同地方放进第三个函数中，并由两个 copying 函数共同调用。

- 工厂模式：
  
- new-delete：如果`new`时用了`[]`，那么`delete`时也一定要带`[]`；

- 以独立语句将 newed （已 new 过） 对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。





## 参考文献

[1] 公众号：[小林coding](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&album_id=1383149653700558849&__biz=MzUxODAzNDg4NQ==#wechat_redirect)